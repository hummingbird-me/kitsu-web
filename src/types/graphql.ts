export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date, expressed as an ISO8601 string */
  Date: string;
  /** An ISO 8601-encoded date */
  ISO8601Date: Date;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: Date;
  /** Represents untyped JSON */
  JSON: Record<string, unknown>;
  /** A loose key-value map in GraphQL */
  Map: Record<string, string>;
  Upload: any;
};

/** A user account on Kitsu */
export type Account = WithTimestamps & {
  readonly __typename?: 'Account';
  /** The country this user resides in */
  readonly country?: Maybe<Scalars['String']>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** The email addresses associated with this account */
  readonly email: ReadonlyArray<Scalars['String']>;
  /** The features this user has access to */
  readonly enabledFeatures: ReadonlyArray<Scalars['String']>;
  /** Facebook account linked to the account */
  readonly facebookId?: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  /** Primary language for the account */
  readonly language?: Maybe<Scalars['String']>;
  /** Longest period an account has had a PRO subscription for in seconds */
  readonly maxProStreak?: Maybe<Scalars['Int']>;
  /** The PRO subscription for this account */
  readonly proSubscription?: Maybe<ProSubscription>;
  /** The profile for this account */
  readonly profile: Profile;
  /** Media rating system used for the account */
  readonly ratingSystem: RatingSystemEnum;
  /** Whether Not Safe For Work content is accessible */
  readonly sfwFilter?: Maybe<Scalars['Boolean']>;
  /** The site-wide permissions this user has access to */
  readonly sitePermissions: ReadonlyArray<SitePermissionEnum>;
  /** Time zone of the account */
  readonly timeZone?: Maybe<Scalars['String']>;
  /** Preferred language for media titles */
  readonly titleLanguagePreference?: Maybe<TitleLanguagePreferenceEnum>;
  /** Twitter account linked to the account */
  readonly twitterId?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

export type AccountCreateErrorsUnion = ValidationError;

export type AccountCreateInput = {
  /** The email address to reset the password for */
  readonly email: Scalars['String'];
  /** An external identity to associate with the account on creation */
  readonly externalIdentity?: InputMaybe<AccountExternalIdentityInput>;
  /** The name of the user */
  readonly name: Scalars['String'];
  /** The password for the user */
  readonly password: Scalars['String'];
};

/** Autogenerated return type of AccountCreate */
export type AccountCreatePayload = {
  readonly __typename?: 'AccountCreatePayload';
  readonly errors?: Maybe<ReadonlyArray<AccountCreateErrorsUnion>>;
  readonly result?: Maybe<Account>;
};

export type AccountExternalIdentityInput = {
  readonly id: Scalars['String'];
  readonly provider: ExternalIdentityProviderEnum;
};

export type AccountMutations = {
  readonly __typename?: 'AccountMutations';
  /** Send a password reset email */
  readonly sendPasswordReset?: Maybe<AccountSendPasswordResetPayload>;
};

export type AccountMutationsSendPasswordResetArgs = {
  email: Scalars['String'];
};

/** Autogenerated return type of AccountSendPasswordReset */
export type AccountSendPasswordResetPayload = {
  readonly __typename?: 'AccountSendPasswordResetPayload';
  readonly email: Scalars['String'];
};

export enum AgeRatingEnum {
  /** Acceptable for all ages */
  G = 'G',
  /** Parental guidance suggested; should be safe for preteens and older */
  Pg = 'PG',
  /** Possible lewd or intense themes; should be safe for teens and older */
  R = 'R',
  /** Contains adult content or themes; should only be viewed by adults */
  R18 = 'R18'
}

/** Generic Amount Consumed based on Media */
export type AmountConsumed = {
  /** Total media completed atleast once. */
  readonly completed: Scalars['Int'];
  readonly id: Scalars['ID'];
  /** Total amount of media. */
  readonly media: Scalars['Int'];
  /** The profile related to the user for this stat. */
  readonly profile: Profile;
  /** Last time we fully recalculated this stat. */
  readonly recalculatedAt: Scalars['ISO8601Date'];
  /** Total progress of library including reconsuming. */
  readonly units: Scalars['Int'];
};

export type Anime = Episodic &
  Media &
  WithTimestamps & {
    readonly __typename?: 'Anime';
    /** The recommended minimum age group for this media */
    readonly ageRating?: Maybe<AgeRatingEnum>;
    /** An explanation of why this received the age rating it did */
    readonly ageRatingGuide?: Maybe<Scalars['String']>;
    /** The average rating of this media amongst all Kitsu users */
    readonly averageRating?: Maybe<Scalars['Float']>;
    /** The rank of this media by rating */
    readonly averageRatingRank?: Maybe<Scalars['Int']>;
    /** A large banner image for this media */
    readonly bannerImage?: Maybe<Image>;
    /** A list of categories for this media */
    readonly categories: CategoryConnection;
    /** The characters who starred in this media */
    readonly characters: MediaCharacterConnection;
    readonly createdAt: Scalars['ISO8601DateTime'];
    /** A brief (mostly spoiler free) summary or description of the media. */
    readonly description: Scalars['Map'];
    /** the day that this media made its final release */
    readonly endDate?: Maybe<Scalars['Date']>;
    /** The number of episodes in this series */
    readonly episodeCount?: Maybe<Scalars['Int']>;
    /** The general length (in seconds) of each episode */
    readonly episodeLength?: Maybe<Scalars['Int']>;
    /** Episodes for this media */
    readonly episodes: EpisodeConnection;
    /** The number of users with this in their favorites */
    readonly favoritesCount?: Maybe<Scalars['Int']>;
    readonly id: Scalars['ID'];
    /** A list of mappings for this media */
    readonly mappings: MappingConnection;
    /** Your library entry related to this media. */
    readonly myLibraryEntry?: Maybe<LibraryEntry>;
    /** A list of your wiki submissions for this media */
    readonly myWikiSubmissions: WikiSubmissionConnection;
    /** The time of the next release of this media */
    readonly nextRelease?: Maybe<Scalars['ISO8601DateTime']>;
    /** The countries in which the media was originally primarily produced */
    readonly originCountries: ReadonlyArray<Scalars['String']>;
    /** The languages the media was originally produced in */
    readonly originLanguages: ReadonlyArray<Scalars['String']>;
    /**
     * The country in which the media was primarily produced
     * @deprecated Replaced with originCountries and originLanguages
     */
    readonly originalLocale?: Maybe<Scalars['String']>;
    /** The poster image of this media */
    readonly posterImage?: Maybe<Image>;
    /** All posts that tag this media. */
    readonly posts: PostConnection;
    /** The companies which helped to produce this media */
    readonly productions: MediaProductionConnection;
    /** A list of quotes from this media */
    readonly quotes: QuoteConnection;
    /** A list of reactions for this media */
    readonly reactions: MediaReactionConnection;
    /** The season this was released in */
    readonly season?: Maybe<ReleaseSeasonEnum>;
    /** Whether the media is Safe-for-Work */
    readonly sfw: Scalars['Boolean'];
    /** The URL-friendly identifier of this media */
    readonly slug: Scalars['String'];
    /** The staff members who worked on this media */
    readonly staff: MediaStaffConnection;
    /** The day that this media first released */
    readonly startDate?: Maybe<Scalars['Date']>;
    /** The current releasing status of this media */
    readonly status: ReleaseStatusEnum;
    /** The stream links. */
    readonly streamingLinks: StreamingLinkConnection;
    /** A secondary type for categorizing Anime. */
    readonly subtype: AnimeSubtypeEnum;
    /** Description of when this media is expected to release */
    readonly tba?: Maybe<Scalars['String']>;
    /** The titles for this media in various locales */
    readonly titles: TitlesList;
    /** The total length (in seconds) of the entire series */
    readonly totalLength?: Maybe<Scalars['Int']>;
    /** Anime or Manga. */
    readonly type: Scalars['String'];
    readonly updatedAt: Scalars['ISO8601DateTime'];
    /** The number of users with this in their library */
    readonly userCount?: Maybe<Scalars['Int']>;
    /** The rank of this media by popularity */
    readonly userCountRank?: Maybe<Scalars['Int']>;
    /** Video id for a trailer on YouTube */
    readonly youtubeTrailerVideoId?: Maybe<Scalars['String']>;
  };

export type AnimeCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaCategorySortOption>>>;
};

export type AnimeCharactersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaCharacterSortOption>>>;
};

export type AnimeDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

export type AnimeEpisodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<EpisodeSortOption>>>;
};

export type AnimeMappingsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AnimeMyWikiSubmissionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<WikiSubmissionSortOption>>>;
};

export type AnimePostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<PostSortOption>>>;
};

export type AnimeProductionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AnimeQuotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AnimeReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaReactionSortOption>>>;
};

export type AnimeStaffArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AnimeStreamingLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AnimeAmountConsumed = AmountConsumed & {
  readonly __typename?: 'AnimeAmountConsumed';
  /** Total media completed atleast once. */
  readonly completed: Scalars['Int'];
  readonly id: Scalars['ID'];
  /** Total amount of media. */
  readonly media: Scalars['Int'];
  /** The profile related to the user for this stat. */
  readonly profile: Profile;
  /** Last time we fully recalculated this stat. */
  readonly recalculatedAt: Scalars['ISO8601Date'];
  /** Total time spent in minutes. */
  readonly time: Scalars['Int'];
  /** Total progress of library including reconsuming. */
  readonly units: Scalars['Int'];
};

export type AnimeCategoryBreakdown = CategoryBreakdown & {
  readonly __typename?: 'AnimeCategoryBreakdown';
  /** A Map of category_id -> count for all categories present on the library entries */
  readonly categories: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** The profile related to the user for this stat. */
  readonly profile: Profile;
  /** Last time we fully recalculated this stat. */
  readonly recalculatedAt: Scalars['ISO8601Date'];
  /** The total amount of library entries. */
  readonly total: Scalars['Int'];
};

/** The connection type for Anime. */
export type AnimeConnection = {
  readonly __typename?: 'AnimeConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<AnimeEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Anime>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

export type AnimeCreateInput = {
  readonly ageRating?: InputMaybe<AgeRatingEnum>;
  readonly ageRatingGuide?: InputMaybe<Scalars['String']>;
  readonly bannerImage?: InputMaybe<Scalars['Upload']>;
  readonly description: Scalars['Map'];
  readonly endDate?: InputMaybe<Scalars['Date']>;
  readonly episodeCount?: InputMaybe<Scalars['Int']>;
  readonly episodeLength?: InputMaybe<Scalars['Int']>;
  readonly posterImage?: InputMaybe<Scalars['Upload']>;
  readonly startDate?: InputMaybe<Scalars['Date']>;
  readonly tba?: InputMaybe<Scalars['String']>;
  readonly titles: TitlesListInput;
  readonly youtubeTrailerVideoId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AnimeCreate */
export type AnimeCreatePayload = {
  readonly __typename?: 'AnimeCreatePayload';
  readonly anime?: Maybe<Anime>;
  readonly errors?: Maybe<ReadonlyArray<Error>>;
};

/** Autogenerated return type of AnimeDelete */
export type AnimeDeletePayload = {
  readonly __typename?: 'AnimeDeletePayload';
  readonly anime?: Maybe<GenericDelete>;
  readonly errors?: Maybe<ReadonlyArray<Error>>;
};

/** An edge in a connection. */
export type AnimeEdge = {
  readonly __typename?: 'AnimeEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Anime>;
};

export type AnimeMutations = {
  readonly __typename?: 'AnimeMutations';
  /** Create an Anime. */
  readonly create?: Maybe<AnimeCreatePayload>;
  /** Delete an Anime. */
  readonly delete?: Maybe<AnimeDeletePayload>;
  /** Update an Anime. */
  readonly update?: Maybe<AnimeUpdatePayload>;
};

export type AnimeMutationsCreateArgs = {
  input: AnimeCreateInput;
};

export type AnimeMutationsDeleteArgs = {
  input: GenericDeleteInput;
};

export type AnimeMutationsUpdateArgs = {
  input: AnimeUpdateInput;
};

export enum AnimeSubtypeEnum {
  Movie = 'MOVIE',
  Music = 'MUSIC',
  /** Original Net Animation (Web Anime). */
  Ona = 'ONA',
  /** Original Video Animation. Anime directly released to video market. */
  Ova = 'OVA',
  /** Spinoffs or Extras of the original. */
  Special = 'SPECIAL',
  Tv = 'TV'
}

export type AnimeUpdateInput = {
  readonly ageRating?: InputMaybe<AgeRatingEnum>;
  readonly ageRatingGuide?: InputMaybe<Scalars['String']>;
  readonly bannerImage?: InputMaybe<Scalars['Upload']>;
  readonly description?: InputMaybe<Scalars['Map']>;
  readonly endDate?: InputMaybe<Scalars['Date']>;
  readonly episodeCount?: InputMaybe<Scalars['Int']>;
  readonly episodeLength?: InputMaybe<Scalars['Int']>;
  readonly id: Scalars['ID'];
  readonly posterImage?: InputMaybe<Scalars['Upload']>;
  readonly startDate?: InputMaybe<Scalars['Date']>;
  readonly tba?: InputMaybe<Scalars['String']>;
  readonly titles?: InputMaybe<TitlesListInput>;
  readonly youtubeTrailerVideoId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AnimeUpdate */
export type AnimeUpdatePayload = {
  readonly __typename?: 'AnimeUpdatePayload';
  readonly anime?: Maybe<Anime>;
  readonly errors?: Maybe<ReadonlyArray<Error>>;
};

/** Information about a specific Category */
export type Category = WithTimestamps & {
  readonly __typename?: 'Category';
  /** The child categories. */
  readonly children?: Maybe<CategoryConnection>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** A brief summary or description of the catgory. */
  readonly description: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** Whether the category is Not-Safe-for-Work. */
  readonly isNsfw: Scalars['Boolean'];
  /** The parent category. Each category can have one parent. */
  readonly parent?: Maybe<Category>;
  /** The top-level ancestor category */
  readonly root?: Maybe<Category>;
  /** The URL-friendly identifier of this Category. */
  readonly slug: Scalars['String'];
  /** The name of the category. */
  readonly title: Scalars['Map'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** Information about a specific Category */
export type CategoryChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Information about a specific Category */
export type CategoryDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** Information about a specific Category */
export type CategoryTitleArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** Generic Category Breakdown based on Media */
export type CategoryBreakdown = {
  /** A Map of category_id -> count for all categories present on the library entries */
  readonly categories: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** The profile related to the user for this stat. */
  readonly profile: Profile;
  /** Last time we fully recalculated this stat. */
  readonly recalculatedAt: Scalars['ISO8601Date'];
  /** The total amount of library entries. */
  readonly total: Scalars['Int'];
};

/** The connection type for Category. */
export type CategoryConnection = {
  readonly __typename?: 'CategoryConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CategoryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Category>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CategoryEdge = {
  readonly __typename?: 'CategoryEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Category>;
};

/** A single chapter of a manga */
export type Chapter = Unit &
  WithTimestamps & {
    readonly __typename?: 'Chapter';
    readonly createdAt: Scalars['ISO8601DateTime'];
    /** A brief summary or description of the unit */
    readonly description: Scalars['Map'];
    readonly id: Scalars['ID'];
    /** The manga this chapter is in. */
    readonly manga: Manga;
    /** The sequence number of this unit */
    readonly number: Scalars['Int'];
    /** When this chapter was released */
    readonly releasedAt?: Maybe<Scalars['ISO8601Date']>;
    /** A thumbnail image for the unit */
    readonly thumbnail?: Maybe<Image>;
    /** The titles for this unit in various locales */
    readonly titles: TitlesList;
    readonly updatedAt: Scalars['ISO8601DateTime'];
    /** The volume this chapter is in. */
    readonly volume?: Maybe<Volume>;
  };

/** A single chapter of a manga */
export type ChapterDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** The connection type for Chapter. */
export type ChapterConnection = {
  readonly __typename?: 'ChapterConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ChapterEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Chapter>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ChapterEdge = {
  readonly __typename?: 'ChapterEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Chapter>;
};

/** Information about a Character in the Kitsu database */
export type Character = WithTimestamps & {
  readonly __typename?: 'Character';
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** A brief summary or description of the character. */
  readonly description: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** An image of the character */
  readonly image?: Maybe<Image>;
  /** Media this character appears in. */
  readonly media?: Maybe<MediaCharacterConnection>;
  /** The name for this character in various locales */
  readonly names?: Maybe<TitlesList>;
  /** The original media this character showed up in */
  readonly primaryMedia?: Maybe<Media>;
  /** The URL-friendly identifier of this character */
  readonly slug: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** Information about a Character in the Kitsu database */
export type CharacterDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** Information about a Character in the Kitsu database */
export type CharacterMediaArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export enum CharacterRoleEnum {
  /** A background character who generally only appears in a few episodes */
  Background = 'BACKGROUND',
  /** A character from a different franchise making a (usually brief) appearance */
  Cameo = 'CAMEO',
  /** A character who appears throughout a series and is a focal point of the media */
  Main = 'MAIN',
  /** A character who appears in multiple episodes but is not a main character */
  Recurring = 'RECURRING'
}

/** Information about a VA (Person) voicing a Character in a Media */
export type CharacterVoice = WithTimestamps & {
  readonly __typename?: 'CharacterVoice';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The company who hired this voice actor to play this role */
  readonly licensor?: Maybe<Producer>;
  /** The BCP47 locale tag for the voice acting role */
  readonly locale: Scalars['String'];
  /** The MediaCharacter node */
  readonly mediaCharacter: MediaCharacter;
  /** The person who voice acted this role */
  readonly person: Person;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for CharacterVoice. */
export type CharacterVoiceConnection = {
  readonly __typename?: 'CharacterVoiceConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CharacterVoiceEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<CharacterVoice>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CharacterVoiceEdge = {
  readonly __typename?: 'CharacterVoiceEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<CharacterVoice>;
};

export enum CharacterVoiceSortEnum {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type CharacterVoiceSortOption = {
  readonly direction: SortDirection;
  readonly on: CharacterVoiceSortEnum;
};

/** A comment on a post */
export type Comment = WithTimestamps & {
  readonly __typename?: 'Comment';
  /** The user who created this comment for the parent post. */
  readonly author: Profile;
  /** Unmodified content. */
  readonly content?: Maybe<Scalars['String']>;
  /** Html formatted content. */
  readonly contentFormatted?: Maybe<Scalars['String']>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** Users who liked this comment */
  readonly likes: ProfileConnection;
  /** The parent comment if this comment was a reply to another. */
  readonly parent?: Maybe<Comment>;
  /** The post that this comment is attached to. */
  readonly post: Post;
  /** Replies to this comment */
  readonly replies: CommentConnection;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A comment on a post */
export type CommentLikesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<CommentLikeSortOption>>>;
};

/** A comment on a post */
export type CommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<CommentSortOption>>>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  readonly __typename?: 'CommentConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<CommentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Comment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CommentEdge = {
  readonly __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Comment>;
};

export enum CommentLikeSortEnum {
  CreatedAt = 'CREATED_AT',
  Following = 'FOLLOWING'
}

export type CommentLikeSortOption = {
  readonly direction: SortDirection;
  readonly on: CommentLikeSortEnum;
};

export enum CommentSortEnum {
  CreatedAt = 'CREATED_AT',
  Following = 'FOLLOWING',
  LikesCount = 'LIKES_COUNT'
}

export type CommentSortOption = {
  readonly direction: SortDirection;
  readonly on: CommentSortEnum;
};

/** An Episode of a Media */
export type Episode = Unit &
  WithTimestamps & {
    readonly __typename?: 'Episode';
    /** The anime this episode is in */
    readonly anime: Anime;
    readonly createdAt: Scalars['ISO8601DateTime'];
    /** A brief summary or description of the unit */
    readonly description: Scalars['Map'];
    readonly id: Scalars['ID'];
    /** The length of the episode in seconds */
    readonly length?: Maybe<Scalars['Int']>;
    /** The sequence number of this unit */
    readonly number: Scalars['Int'];
    /** When this episode aired */
    readonly releasedAt?: Maybe<Scalars['ISO8601DateTime']>;
    /** A thumbnail image for the unit */
    readonly thumbnail?: Maybe<Image>;
    /** The titles for this unit in various locales */
    readonly titles: TitlesList;
    readonly updatedAt: Scalars['ISO8601DateTime'];
  };

/** An Episode of a Media */
export type EpisodeDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** The connection type for Episode. */
export type EpisodeConnection = {
  readonly __typename?: 'EpisodeConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<EpisodeEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Episode>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

export type EpisodeCreateInput = {
  readonly description?: InputMaybe<Scalars['Map']>;
  readonly length?: InputMaybe<Scalars['Int']>;
  readonly mediaId: Scalars['ID'];
  readonly mediaType: MediaTypeEnum;
  readonly number: Scalars['Int'];
  readonly releasedAt?: InputMaybe<Scalars['Date']>;
  readonly thumbnailImage?: InputMaybe<Scalars['Upload']>;
  readonly titles: TitlesListInput;
};

/** Autogenerated return type of EpisodeCreate */
export type EpisodeCreatePayload = {
  readonly __typename?: 'EpisodeCreatePayload';
  readonly episode?: Maybe<Episode>;
  readonly errors?: Maybe<ReadonlyArray<Error>>;
};

/** Autogenerated return type of EpisodeDelete */
export type EpisodeDeletePayload = {
  readonly __typename?: 'EpisodeDeletePayload';
  readonly episode?: Maybe<GenericDelete>;
  readonly errors?: Maybe<ReadonlyArray<Error>>;
};

/** An edge in a connection. */
export type EpisodeEdge = {
  readonly __typename?: 'EpisodeEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Episode>;
};

export type EpisodeMutations = {
  readonly __typename?: 'EpisodeMutations';
  /** Create an Episode. */
  readonly create?: Maybe<EpisodeCreatePayload>;
  /** Delete an Episode. */
  readonly delete?: Maybe<EpisodeDeletePayload>;
  /** Update an Episode. */
  readonly update?: Maybe<EpisodeUpdatePayload>;
};

export type EpisodeMutationsCreateArgs = {
  input: EpisodeCreateInput;
};

export type EpisodeMutationsDeleteArgs = {
  input: GenericDeleteInput;
};

export type EpisodeMutationsUpdateArgs = {
  input: EpisodeUpdateInput;
};

export enum EpisodeSortEnum {
  CreatedAt = 'CREATED_AT',
  Number = 'NUMBER',
  UpdatedAt = 'UPDATED_AT'
}

export type EpisodeSortOption = {
  readonly direction: SortDirection;
  readonly on: EpisodeSortEnum;
};

export type EpisodeUpdateInput = {
  readonly description?: InputMaybe<Scalars['Map']>;
  readonly id: Scalars['ID'];
  readonly length?: InputMaybe<Scalars['Int']>;
  readonly number?: InputMaybe<Scalars['Int']>;
  readonly releasedAt?: InputMaybe<Scalars['Date']>;
  readonly thumbnailImage?: InputMaybe<Scalars['Upload']>;
  readonly titles?: InputMaybe<TitlesListInput>;
};

/** Autogenerated return type of EpisodeUpdate */
export type EpisodeUpdatePayload = {
  readonly __typename?: 'EpisodeUpdatePayload';
  readonly episode?: Maybe<Episode>;
  readonly errors?: Maybe<ReadonlyArray<Error>>;
};

/** An episodic media in the Kitsu database */
export type Episodic = {
  /** The number of episodes in this series */
  readonly episodeCount?: Maybe<Scalars['Int']>;
  /** The general length (in seconds) of each episode */
  readonly episodeLength?: Maybe<Scalars['Int']>;
  /** Episodes for this media */
  readonly episodes: EpisodeConnection;
  /** The total length (in seconds) of the entire series */
  readonly totalLength?: Maybe<Scalars['Int']>;
};

/** An episodic media in the Kitsu database */
export type EpisodicEpisodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<EpisodeSortOption>>>;
};

/** Generic error fields used by all errors. */
export type Error = {
  /** The error code. */
  readonly code?: Maybe<Scalars['String']>;
  /** A description of the error */
  readonly message: Scalars['String'];
  /** Which input value this error came from */
  readonly path?: Maybe<ReadonlyArray<Scalars['String']>>;
};

export enum ExternalIdentityProviderEnum {
  /** Facebook identity */
  Facebook = 'FACEBOOK'
}

/** Favorite media, characters, and people for a user */
export type Favorite = WithTimestamps & {
  readonly __typename?: 'Favorite';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The kitsu object that is mapped */
  readonly item: FavoriteItemUnion;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** The user who favorited this item */
  readonly user: Profile;
};

/** The connection type for Favorite. */
export type FavoriteConnection = {
  readonly __typename?: 'FavoriteConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<FavoriteEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Favorite>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type FavoriteEdge = {
  readonly __typename?: 'FavoriteEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Favorite>;
};

/** Objects which are Favoritable */
export type FavoriteItemUnion = Anime | Character | Manga | Person;

export enum FollowSortEnum {
  CreatedAt = 'CREATED_AT',
  FollowingFollowed = 'FOLLOWING_FOLLOWED',
  FollowingFollower = 'FOLLOWING_FOLLOWER'
}

export type FollowSortOption = {
  readonly direction: SortDirection;
  readonly on: FollowSortEnum;
};

/** Related media grouped together */
export type Franchise = WithTimestamps & {
  readonly __typename?: 'Franchise';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** All media related to a franchise */
  readonly installments?: Maybe<InstallmentConnection>;
  /** The name of this franchise in various languages */
  readonly titles: TitlesList;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** Related media grouped together */
export type FranchiseInstallmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<InstallmentSortOption>>>;
};

/** The connection type for Franchise. */
export type FranchiseConnection = {
  readonly __typename?: 'FranchiseConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<FranchiseEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Franchise>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type FranchiseEdge = {
  readonly __typename?: 'FranchiseEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Franchise>;
};

export type GenericDelete = {
  readonly __typename?: 'GenericDelete';
  readonly id: Scalars['ID'];
};

export type GenericDeleteInput = {
  readonly id: Scalars['ID'];
};

export type GenericError = Error & {
  readonly __typename?: 'GenericError';
  /** The error code. */
  readonly code?: Maybe<Scalars['String']>;
  /** A description of the error */
  readonly message: Scalars['String'];
  /** Which input value this error came from */
  readonly path?: Maybe<ReadonlyArray<Scalars['String']>>;
};

export type Image = {
  readonly __typename?: 'Image';
  /** A blurhash-encoded version of this image */
  readonly blurhash?: Maybe<Scalars['String']>;
  /** The original image */
  readonly original: ImageView;
  /** The various generated views of this image */
  readonly views: ReadonlyArray<ImageView>;
};

export type ImageViewsArgs = {
  names?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

export type ImageView = {
  readonly __typename?: 'ImageView';
  /** The height of the image */
  readonly height?: Maybe<Scalars['Int']>;
  /** The name of this view of the image */
  readonly name: Scalars['String'];
  /** The URL of this view of the image */
  readonly url: Scalars['String'];
  /** The width of the image */
  readonly width?: Maybe<Scalars['Int']>;
};

/** Individual media that belongs to a franchise */
export type Installment = WithTimestamps & {
  readonly __typename?: 'Installment';
  /** Order based chronologically */
  readonly alternativeOrder?: Maybe<Scalars['Int']>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** The franchise related to this installment */
  readonly franchise: Franchise;
  readonly id: Scalars['ID'];
  /** The media related to this installment */
  readonly media: Media;
  /** Order based by date released */
  readonly releaseOrder?: Maybe<Scalars['Int']>;
  /** Further explains the media relationship corresponding to a franchise */
  readonly tag?: Maybe<InstallmentTagEnum>;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Installment. */
export type InstallmentConnection = {
  readonly __typename?: 'InstallmentConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<InstallmentEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Installment>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type InstallmentEdge = {
  readonly __typename?: 'InstallmentEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Installment>;
};

export enum InstallmentSortEnum {
  AlternativeOrder = 'ALTERNATIVE_ORDER',
  ReleaseOrder = 'RELEASE_ORDER'
}

export type InstallmentSortOption = {
  readonly direction: SortDirection;
  readonly on: InstallmentSortEnum;
};

export enum InstallmentTagEnum {
  /** Same universe/world/reality/timeline, completely different characters. */
  AlternateSetting = 'ALTERNATE_SETTING',
  /** Same setting, same characters, story is told differently. */
  AlternateVersion = 'ALTERNATE_VERSION',
  /** Characters from different media meet in the same story. */
  Crossover = 'CROSSOVER',
  /** The main story. */
  MainStory = 'MAIN_STORY',
  /** Takes place sometime during the main storyline. */
  SideStory = 'SIDE_STORY',
  /** Uses characters of a different series, but is not an alternate setting or story. */
  Spinoff = 'SPINOFF'
}

/** The user library filterable by media_type and status */
export type Library = {
  readonly __typename?: 'Library';
  /** All Library Entries for a specific Media */
  readonly all: LibraryEntryConnection;
  /** Library Entries for a specific Media filtered by the completed status */
  readonly completed: LibraryEntryConnection;
  /** Library Entries for a specific Media filtered by the current status */
  readonly current: LibraryEntryConnection;
  /** Library Entries for a specific Media filtered by the dropped status */
  readonly dropped: LibraryEntryConnection;
  /** Library Entries for a specific Media filtered by the on_hold status */
  readonly onHold: LibraryEntryConnection;
  /** Library Entries for a specific Media filtered by the planned status */
  readonly planned: LibraryEntryConnection;
  /** Random anime or manga from this library */
  readonly randomMedia?: Maybe<Media>;
};

/** The user library filterable by media_type and status */
export type LibraryAllArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
  status?: InputMaybe<ReadonlyArray<LibraryEntryStatusEnum>>;
};

/** The user library filterable by media_type and status */
export type LibraryCompletedArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

/** The user library filterable by media_type and status */
export type LibraryCurrentArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

/** The user library filterable by media_type and status */
export type LibraryDroppedArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

/** The user library filterable by media_type and status */
export type LibraryOnHoldArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

/** The user library filterable by media_type and status */
export type LibraryPlannedArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

/** The user library filterable by media_type and status */
export type LibraryRandomMediaArgs = {
  mediaType: MediaTypeEnum;
  status: ReadonlyArray<LibraryEntryStatusEnum>;
};

/** Information about a specific media entry for a user */
export type LibraryEntry = WithTimestamps & {
  readonly __typename?: 'LibraryEntry';
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** History of user actions for this library entry. */
  readonly events?: Maybe<LibraryEventConnection>;
  /** When the user finished this media. */
  readonly finishedAt?: Maybe<Scalars['ISO8601DateTime']>;
  readonly id: Scalars['ID'];
  /** The last unit consumed */
  readonly lastUnit?: Maybe<Unit>;
  /** The media related to this library entry. */
  readonly media: Media;
  /** The next unit to be consumed */
  readonly nextUnit?: Maybe<Unit>;
  /** Notes left by the profile related to this library entry. */
  readonly notes?: Maybe<Scalars['String']>;
  /** If the media related to the library entry is Not-Safe-for-Work. */
  readonly nsfw: Scalars['Boolean'];
  /** If this library entry is publicly visibile from their profile, or hidden. */
  readonly private: Scalars['Boolean'];
  /** The number of episodes/chapters this user has watched/read */
  readonly progress: Scalars['Int'];
  /** When the user last watched an episode or read a chapter of this media. */
  readonly progressedAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** How much you enjoyed this media (lower meaning not liking). */
  readonly rating?: Maybe<Scalars['Int']>;
  /** The reaction based on the media of this library entry. */
  readonly reaction?: Maybe<MediaReaction>;
  /** Amount of times this media has been rewatched. */
  readonly reconsumeCount: Scalars['Int'];
  /** If the profile is currently rewatching this media. */
  readonly reconsuming: Scalars['Boolean'];
  /** When the user started this media. */
  readonly startedAt?: Maybe<Scalars['ISO8601DateTime']>;
  readonly status: LibraryEntryStatusEnum;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** The user who created this library entry. */
  readonly user: Profile;
  /** Volumes that the profile owns (physically or digital). */
  readonly volumesOwned: Scalars['Int'];
};

/** Information about a specific media entry for a user */
export type LibraryEntryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaTypes?: InputMaybe<ReadonlyArray<MediaTypeEnum>>;
};

/** The connection type for LibraryEntry. */
export type LibraryEntryConnection = {
  readonly __typename?: 'LibraryEntryConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<LibraryEntryEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<LibraryEntry>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

export type LibraryEntryCreateInput = {
  readonly finishedAt?: InputMaybe<Scalars['ISO8601DateTime']>;
  readonly mediaId: Scalars['ID'];
  readonly mediaType: MediaTypeEnum;
  readonly notes?: InputMaybe<Scalars['String']>;
  readonly private?: InputMaybe<Scalars['Boolean']>;
  readonly progress?: InputMaybe<Scalars['Int']>;
  readonly rating?: InputMaybe<Scalars['Int']>;
  readonly reconsumeCount?: InputMaybe<Scalars['Int']>;
  readonly reconsuming?: InputMaybe<Scalars['Boolean']>;
  readonly startedAt?: InputMaybe<Scalars['ISO8601DateTime']>;
  readonly status: LibraryEntryStatusEnum;
  readonly volumesOwned?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of LibraryEntryCreate */
export type LibraryEntryCreatePayload = {
  readonly __typename?: 'LibraryEntryCreatePayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

/** Autogenerated return type of LibraryEntryDelete */
export type LibraryEntryDeletePayload = {
  readonly __typename?: 'LibraryEntryDeletePayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<GenericDelete>;
};

/** An edge in a connection. */
export type LibraryEntryEdge = {
  readonly __typename?: 'LibraryEntryEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<LibraryEntry>;
};

export type LibraryEntryMutations = {
  readonly __typename?: 'LibraryEntryMutations';
  /** Create a library entry */
  readonly create?: Maybe<LibraryEntryCreatePayload>;
  /** Delete a library entry */
  readonly delete?: Maybe<LibraryEntryDeletePayload>;
  /** Update a library entry */
  readonly update?: Maybe<LibraryEntryUpdatePayload>;
  /** Update library entry progress by id */
  readonly updateProgressById?: Maybe<LibraryEntryUpdateProgressByIdPayload>;
  /** Update library entry progress by media */
  readonly updateProgressByMedia?: Maybe<LibraryEntryUpdateProgressByMediaPayload>;
  /** Update library entry rating by id */
  readonly updateRatingById?: Maybe<LibraryEntryUpdateRatingByIdPayload>;
  /** Update library entry rating by media */
  readonly updateRatingByMedia?: Maybe<LibraryEntryUpdateRatingByMediaPayload>;
  /** Update library entry status by id */
  readonly updateStatusById?: Maybe<LibraryEntryUpdateStatusByIdPayload>;
  /** Update library entry status by media */
  readonly updateStatusByMedia?: Maybe<LibraryEntryUpdateStatusByMediaPayload>;
};

export type LibraryEntryMutationsCreateArgs = {
  input: LibraryEntryCreateInput;
};

export type LibraryEntryMutationsDeleteArgs = {
  input: GenericDeleteInput;
};

export type LibraryEntryMutationsUpdateArgs = {
  input: LibraryEntryUpdateInput;
};

export type LibraryEntryMutationsUpdateProgressByIdArgs = {
  input: LibraryEntryUpdateProgressByIdInput;
};

export type LibraryEntryMutationsUpdateProgressByMediaArgs = {
  input: LibraryEntryUpdateProgressByMediaInput;
};

export type LibraryEntryMutationsUpdateRatingByIdArgs = {
  input: LibraryEntryUpdateRatingByIdInput;
};

export type LibraryEntryMutationsUpdateRatingByMediaArgs = {
  input: LibraryEntryUpdateRatingByMediaInput;
};

export type LibraryEntryMutationsUpdateStatusByIdArgs = {
  input: LibraryEntryUpdateStatusByIdInput;
};

export type LibraryEntryMutationsUpdateStatusByMediaArgs = {
  input: LibraryEntryUpdateStatusByMediaInput;
};

export enum LibraryEntryStatusEnum {
  /** The user completed this media. */
  Completed = 'COMPLETED',
  /** The user is currently reading or watching this media. */
  Current = 'CURRENT',
  /** The user started but chose not to finish this media. */
  Dropped = 'DROPPED',
  /** The user started but paused reading or watching this media. */
  OnHold = 'ON_HOLD',
  /** The user plans to read or watch this media in future. */
  Planned = 'PLANNED'
}

export type LibraryEntryUpdateInput = {
  readonly finishedAt?: InputMaybe<Scalars['ISO8601DateTime']>;
  readonly id: Scalars['ID'];
  readonly notes?: InputMaybe<Scalars['String']>;
  readonly private?: InputMaybe<Scalars['Boolean']>;
  readonly progress?: InputMaybe<Scalars['Int']>;
  readonly rating?: InputMaybe<Scalars['Int']>;
  readonly reconsumeCount?: InputMaybe<Scalars['Int']>;
  readonly reconsuming?: InputMaybe<Scalars['Boolean']>;
  readonly startedAt?: InputMaybe<Scalars['ISO8601DateTime']>;
  readonly status?: InputMaybe<LibraryEntryStatusEnum>;
  readonly volumesOwned?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of LibraryEntryUpdate */
export type LibraryEntryUpdatePayload = {
  readonly __typename?: 'LibraryEntryUpdatePayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

export type LibraryEntryUpdateProgressByIdInput = {
  readonly id: Scalars['ID'];
  readonly progress: Scalars['Int'];
};

/** Autogenerated return type of LibraryEntryUpdateProgressById */
export type LibraryEntryUpdateProgressByIdPayload = {
  readonly __typename?: 'LibraryEntryUpdateProgressByIdPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

export type LibraryEntryUpdateProgressByMediaInput = {
  readonly mediaId: Scalars['ID'];
  readonly mediaType: MediaTypeEnum;
  readonly progress: Scalars['Int'];
};

/** Autogenerated return type of LibraryEntryUpdateProgressByMedia */
export type LibraryEntryUpdateProgressByMediaPayload = {
  readonly __typename?: 'LibraryEntryUpdateProgressByMediaPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

export type LibraryEntryUpdateRatingByIdInput = {
  readonly id: Scalars['ID'];
  /** A number between 2 - 20 */
  readonly rating: Scalars['Int'];
};

/** Autogenerated return type of LibraryEntryUpdateRatingById */
export type LibraryEntryUpdateRatingByIdPayload = {
  readonly __typename?: 'LibraryEntryUpdateRatingByIdPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

export type LibraryEntryUpdateRatingByMediaInput = {
  readonly mediaId: Scalars['ID'];
  readonly mediaType: MediaTypeEnum;
  /** A number between 2 - 20 */
  readonly rating: Scalars['Int'];
};

/** Autogenerated return type of LibraryEntryUpdateRatingByMedia */
export type LibraryEntryUpdateRatingByMediaPayload = {
  readonly __typename?: 'LibraryEntryUpdateRatingByMediaPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

export type LibraryEntryUpdateStatusByIdInput = {
  readonly id: Scalars['ID'];
  readonly status: LibraryEntryStatusEnum;
};

/** Autogenerated return type of LibraryEntryUpdateStatusById */
export type LibraryEntryUpdateStatusByIdPayload = {
  readonly __typename?: 'LibraryEntryUpdateStatusByIdPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

export type LibraryEntryUpdateStatusByMediaInput = {
  readonly mediaId: Scalars['ID'];
  readonly mediaType: MediaTypeEnum;
  readonly status: LibraryEntryStatusEnum;
};

/** Autogenerated return type of LibraryEntryUpdateStatusByMedia */
export type LibraryEntryUpdateStatusByMediaPayload = {
  readonly __typename?: 'LibraryEntryUpdateStatusByMediaPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly libraryEntry?: Maybe<LibraryEntry>;
};

/** History of user actions for a library entry. */
export type LibraryEvent = WithTimestamps & {
  readonly __typename?: 'LibraryEvent';
  /** The data that was changed for this library event. */
  readonly changedData: Scalars['Map'];
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The type of library event. */
  readonly kind: LibraryEventKindEnum;
  /** The library entry related to this library event. */
  readonly libraryEntry: LibraryEntry;
  /** The media related to this library event. */
  readonly media: Media;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** The user who created this library event */
  readonly user: Profile;
};

/** The connection type for LibraryEvent. */
export type LibraryEventConnection = {
  readonly __typename?: 'LibraryEventConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<LibraryEventEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<LibraryEvent>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LibraryEventEdge = {
  readonly __typename?: 'LibraryEventEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<LibraryEvent>;
};

export enum LibraryEventKindEnum {
  /** Notes were added/updated. */
  Annotated = 'ANNOTATED',
  /** Progress or Time Spent was added/updated. */
  Progressed = 'PROGRESSED',
  /** Rating was added/updated. */
  Rated = 'RATED',
  /** Reaction was added/updated. */
  Reacted = 'REACTED',
  /** Status or Reconsuming was added/updated. */
  Updated = 'UPDATED'
}

export enum LibraryEventSortEnum {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type LibraryEventSortOption = {
  readonly direction: SortDirection;
  readonly on: LibraryEventSortEnum;
};

export enum LockedReasonEnum {
  Closed = 'CLOSED',
  Spam = 'SPAM',
  TooHeated = 'TOO_HEATED'
}

export type Manga = Media &
  WithTimestamps & {
    readonly __typename?: 'Manga';
    /** The recommended minimum age group for this media */
    readonly ageRating?: Maybe<AgeRatingEnum>;
    /** An explanation of why this received the age rating it did */
    readonly ageRatingGuide?: Maybe<Scalars['String']>;
    /** The average rating of this media amongst all Kitsu users */
    readonly averageRating?: Maybe<Scalars['Float']>;
    /** The rank of this media by rating */
    readonly averageRatingRank?: Maybe<Scalars['Int']>;
    /** A large banner image for this media */
    readonly bannerImage?: Maybe<Image>;
    /** A list of categories for this media */
    readonly categories: CategoryConnection;
    /** The number of chapters in this manga. */
    readonly chapterCount?: Maybe<Scalars['Int']>;
    /** The estimated number of chapters in this manga. */
    readonly chapterCountGuess?: Maybe<Scalars['Int']>;
    /** The chapters in the manga. */
    readonly chapters?: Maybe<ChapterConnection>;
    /** The characters who starred in this media */
    readonly characters: MediaCharacterConnection;
    readonly createdAt: Scalars['ISO8601DateTime'];
    /** A brief (mostly spoiler free) summary or description of the media. */
    readonly description: Scalars['Map'];
    /** the day that this media made its final release */
    readonly endDate?: Maybe<Scalars['Date']>;
    /** The number of users with this in their favorites */
    readonly favoritesCount?: Maybe<Scalars['Int']>;
    readonly id: Scalars['ID'];
    /** A list of mappings for this media */
    readonly mappings: MappingConnection;
    /** Your library entry related to this media. */
    readonly myLibraryEntry?: Maybe<LibraryEntry>;
    /** A list of your wiki submissions for this media */
    readonly myWikiSubmissions: WikiSubmissionConnection;
    /** The time of the next release of this media */
    readonly nextRelease?: Maybe<Scalars['ISO8601DateTime']>;
    /** The countries in which the media was originally primarily produced */
    readonly originCountries: ReadonlyArray<Scalars['String']>;
    /** The languages the media was originally produced in */
    readonly originLanguages: ReadonlyArray<Scalars['String']>;
    /**
     * The country in which the media was primarily produced
     * @deprecated Replaced with originCountries and originLanguages
     */
    readonly originalLocale?: Maybe<Scalars['String']>;
    /** The poster image of this media */
    readonly posterImage?: Maybe<Image>;
    /** All posts that tag this media. */
    readonly posts: PostConnection;
    /** The companies which helped to produce this media */
    readonly productions: MediaProductionConnection;
    /** A list of quotes from this media */
    readonly quotes: QuoteConnection;
    /** A list of reactions for this media */
    readonly reactions: MediaReactionConnection;
    /** Whether the media is Safe-for-Work */
    readonly sfw: Scalars['Boolean'];
    /** The URL-friendly identifier of this media */
    readonly slug: Scalars['String'];
    /** The staff members who worked on this media */
    readonly staff: MediaStaffConnection;
    /** The day that this media first released */
    readonly startDate?: Maybe<Scalars['Date']>;
    /** The current releasing status of this media */
    readonly status: ReleaseStatusEnum;
    /** A secondary type for categorizing Manga. */
    readonly subtype: MangaSubtypeEnum;
    /** Description of when this media is expected to release */
    readonly tba?: Maybe<Scalars['String']>;
    /** The titles for this media in various locales */
    readonly titles: TitlesList;
    /** Anime or Manga. */
    readonly type: Scalars['String'];
    readonly updatedAt: Scalars['ISO8601DateTime'];
    /** The number of users with this in their library */
    readonly userCount?: Maybe<Scalars['Int']>;
    /** The rank of this media by popularity */
    readonly userCountRank?: Maybe<Scalars['Int']>;
    /** The number of volumes in this manga. */
    readonly volumeCount?: Maybe<Scalars['Int']>;
  };

export type MangaCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaCategorySortOption>>>;
};

export type MangaChaptersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<CharacterVoiceSortOption>>>;
};

export type MangaCharactersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaCharacterSortOption>>>;
};

export type MangaDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

export type MangaMappingsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type MangaMyWikiSubmissionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<WikiSubmissionSortOption>>>;
};

export type MangaPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<PostSortOption>>>;
};

export type MangaProductionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type MangaQuotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type MangaReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaReactionSortOption>>>;
};

export type MangaStaffArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type MangaAmountConsumed = AmountConsumed & {
  readonly __typename?: 'MangaAmountConsumed';
  /** Total media completed atleast once. */
  readonly completed: Scalars['Int'];
  readonly id: Scalars['ID'];
  /** Total amount of media. */
  readonly media: Scalars['Int'];
  /** The profile related to the user for this stat. */
  readonly profile: Profile;
  /** Last time we fully recalculated this stat. */
  readonly recalculatedAt: Scalars['ISO8601Date'];
  /** Total progress of library including reconsuming. */
  readonly units: Scalars['Int'];
};

export type MangaCategoryBreakdown = CategoryBreakdown & {
  readonly __typename?: 'MangaCategoryBreakdown';
  /** A Map of category_id -> count for all categories present on the library entries */
  readonly categories: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** The profile related to the user for this stat. */
  readonly profile: Profile;
  /** Last time we fully recalculated this stat. */
  readonly recalculatedAt: Scalars['ISO8601Date'];
  /** The total amount of library entries. */
  readonly total: Scalars['Int'];
};

/** The connection type for Manga. */
export type MangaConnection = {
  readonly __typename?: 'MangaConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MangaEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Manga>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MangaEdge = {
  readonly __typename?: 'MangaEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Manga>;
};

export enum MangaSubtypeEnum {
  /** Self published work. */
  Doujin = 'DOUJIN',
  Manga = 'MANGA',
  /** Chinese comics produced in China and in the Greater China region. */
  Manhua = 'MANHUA',
  /** A style of South Korean comic books and graphic novels */
  Manhwa = 'MANHWA',
  Novel = 'NOVEL',
  /** Original English Language. */
  Oel = 'OEL',
  Oneshot = 'ONESHOT'
}

/** Media Mappings from External Sites (MAL, Anilist, etc..) to Kitsu. */
export type Mapping = WithTimestamps & {
  readonly __typename?: 'Mapping';
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** The ID of the media from the external site. */
  readonly externalId: Scalars['ID'];
  /** The name of the site which kitsu media is being linked from. */
  readonly externalSite: MappingExternalSiteEnum;
  readonly id: Scalars['ID'];
  /** The kitsu object that is mapped. */
  readonly item: MappingItemUnion;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Mapping. */
export type MappingConnection = {
  readonly __typename?: 'MappingConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MappingEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Mapping>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

export type MappingCreateInput = {
  readonly externalId: Scalars['ID'];
  readonly externalSite: MappingExternalSiteEnum;
  readonly itemId: Scalars['ID'];
  readonly itemType: MappingItemEnum;
};

/** Autogenerated return type of MappingCreate */
export type MappingCreatePayload = {
  readonly __typename?: 'MappingCreatePayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly mapping?: Maybe<Mapping>;
};

/** Autogenerated return type of MappingDelete */
export type MappingDeletePayload = {
  readonly __typename?: 'MappingDeletePayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly mapping?: Maybe<GenericDelete>;
};

/** An edge in a connection. */
export type MappingEdge = {
  readonly __typename?: 'MappingEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Mapping>;
};

export enum MappingExternalSiteEnum {
  Anidb = 'ANIDB',
  AnilistAnime = 'ANILIST_ANIME',
  AnilistManga = 'ANILIST_MANGA',
  Animenewsnetwork = 'ANIMENEWSNETWORK',
  Aozora = 'AOZORA',
  Hulu = 'HULU',
  ImdbEpisodes = 'IMDB_EPISODES',
  Mangaupdates = 'MANGAUPDATES',
  MyanimelistAnime = 'MYANIMELIST_ANIME',
  MyanimelistCharacters = 'MYANIMELIST_CHARACTERS',
  MyanimelistManga = 'MYANIMELIST_MANGA',
  MyanimelistPeople = 'MYANIMELIST_PEOPLE',
  MyanimelistProducers = 'MYANIMELIST_PRODUCERS',
  Mydramalist = 'MYDRAMALIST',
  Thetvdb = 'THETVDB',
  ThetvdbSeason = 'THETVDB_SEASON',
  ThetvdbSeries = 'THETVDB_SERIES',
  Trakt = 'TRAKT'
}

export enum MappingItemEnum {
  Anime = 'ANIME',
  Category = 'CATEGORY',
  Character = 'CHARACTER',
  Episode = 'EPISODE',
  Manga = 'MANGA',
  Person = 'PERSON',
  Producer = 'PRODUCER'
}

/** Objects which are Mappable */
export type MappingItemUnion =
  | Anime
  | Category
  | Character
  | Episode
  | Manga
  | Person
  | Producer;

export type MappingMutations = {
  readonly __typename?: 'MappingMutations';
  /** Create a Mapping */
  readonly create?: Maybe<MappingCreatePayload>;
  /** Delete a Mapping */
  readonly delete?: Maybe<MappingDeletePayload>;
  /** Update a Mapping */
  readonly update?: Maybe<MappingUpdatePayload>;
};

export type MappingMutationsCreateArgs = {
  input: MappingCreateInput;
};

export type MappingMutationsDeleteArgs = {
  input: GenericDeleteInput;
};

export type MappingMutationsUpdateArgs = {
  input: MappingUpdateInput;
};

export type MappingUpdateInput = {
  readonly externalId?: InputMaybe<Scalars['ID']>;
  readonly externalSite?: InputMaybe<MappingExternalSiteEnum>;
  readonly id: Scalars['ID'];
  readonly itemId?: InputMaybe<Scalars['ID']>;
  readonly itemType?: InputMaybe<MappingItemEnum>;
};

/** Autogenerated return type of MappingUpdate */
export type MappingUpdatePayload = {
  readonly __typename?: 'MappingUpdatePayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly mapping?: Maybe<Mapping>;
};

/** A media in the Kitsu database */
export type Media = {
  /** The recommended minimum age group for this media */
  readonly ageRating?: Maybe<AgeRatingEnum>;
  /** An explanation of why this received the age rating it did */
  readonly ageRatingGuide?: Maybe<Scalars['String']>;
  /** The average rating of this media amongst all Kitsu users */
  readonly averageRating?: Maybe<Scalars['Float']>;
  /** The rank of this media by rating */
  readonly averageRatingRank?: Maybe<Scalars['Int']>;
  /** A large banner image for this media */
  readonly bannerImage?: Maybe<Image>;
  /** A list of categories for this media */
  readonly categories: CategoryConnection;
  /** The characters who starred in this media */
  readonly characters: MediaCharacterConnection;
  /** A brief (mostly spoiler free) summary or description of the media. */
  readonly description: Scalars['Map'];
  /** the day that this media made its final release */
  readonly endDate?: Maybe<Scalars['Date']>;
  /** The number of users with this in their favorites */
  readonly favoritesCount?: Maybe<Scalars['Int']>;
  readonly id: Scalars['ID'];
  /** A list of mappings for this media */
  readonly mappings: MappingConnection;
  /** Your library entry related to this media. */
  readonly myLibraryEntry?: Maybe<LibraryEntry>;
  /** A list of your wiki submissions for this media */
  readonly myWikiSubmissions: WikiSubmissionConnection;
  /** The time of the next release of this media */
  readonly nextRelease?: Maybe<Scalars['ISO8601DateTime']>;
  /** The countries in which the media was originally primarily produced */
  readonly originCountries: ReadonlyArray<Scalars['String']>;
  /** The languages the media was originally produced in */
  readonly originLanguages: ReadonlyArray<Scalars['String']>;
  /**
   * The country in which the media was primarily produced
   * @deprecated Replaced with originCountries and originLanguages
   */
  readonly originalLocale?: Maybe<Scalars['String']>;
  /** The poster image of this media */
  readonly posterImage?: Maybe<Image>;
  /** All posts that tag this media. */
  readonly posts: PostConnection;
  /** The companies which helped to produce this media */
  readonly productions: MediaProductionConnection;
  /** A list of quotes from this media */
  readonly quotes: QuoteConnection;
  /** A list of reactions for this media */
  readonly reactions: MediaReactionConnection;
  /** Whether the media is Safe-for-Work */
  readonly sfw: Scalars['Boolean'];
  /** The URL-friendly identifier of this media */
  readonly slug: Scalars['String'];
  /** The staff members who worked on this media */
  readonly staff: MediaStaffConnection;
  /** The day that this media first released */
  readonly startDate?: Maybe<Scalars['Date']>;
  /** The current releasing status of this media */
  readonly status: ReleaseStatusEnum;
  /** Description of when this media is expected to release */
  readonly tba?: Maybe<Scalars['String']>;
  /** The titles for this media in various locales */
  readonly titles: TitlesList;
  /** Anime or Manga. */
  readonly type: Scalars['String'];
  /** The number of users with this in their library */
  readonly userCount?: Maybe<Scalars['Int']>;
  /** The rank of this media by popularity */
  readonly userCountRank?: Maybe<Scalars['Int']>;
};

/** A media in the Kitsu database */
export type MediaCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaCategorySortOption>>>;
};

/** A media in the Kitsu database */
export type MediaCharactersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaCharacterSortOption>>>;
};

/** A media in the Kitsu database */
export type MediaDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** A media in the Kitsu database */
export type MediaMappingsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A media in the Kitsu database */
export type MediaMyWikiSubmissionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<WikiSubmissionSortOption>>>;
};

/** A media in the Kitsu database */
export type MediaPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<PostSortOption>>>;
};

/** A media in the Kitsu database */
export type MediaProductionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A media in the Kitsu database */
export type MediaQuotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A media in the Kitsu database */
export type MediaReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaReactionSortOption>>>;
};

/** A media in the Kitsu database */
export type MediaStaffArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export enum MediaCategorySortEnum {
  Ancestry = 'ANCESTRY',
  CreatedAt = 'CREATED_AT'
}

export type MediaCategorySortOption = {
  readonly direction: SortDirection;
  readonly on: MediaCategorySortEnum;
};

/** Information about a Character starring in a Media */
export type MediaCharacter = WithTimestamps & {
  readonly __typename?: 'MediaCharacter';
  /** The character */
  readonly character: Character;
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The media */
  readonly media: Media;
  /** The role this character had in the media */
  readonly role: CharacterRoleEnum;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** The voices of this character */
  readonly voices?: Maybe<CharacterVoiceConnection>;
};

/** Information about a Character starring in a Media */
export type MediaCharacterVoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locale?: InputMaybe<ReadonlyArray<Scalars['String']>>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<CharacterVoiceSortOption>>>;
};

/** The connection type for MediaCharacter. */
export type MediaCharacterConnection = {
  readonly __typename?: 'MediaCharacterConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaCharacterEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaCharacter>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MediaCharacterEdge = {
  readonly __typename?: 'MediaCharacterEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<MediaCharacter>;
};

export enum MediaCharacterSortEnum {
  CreatedAt = 'CREATED_AT',
  Role = 'ROLE',
  UpdatedAt = 'UPDATED_AT'
}

export type MediaCharacterSortOption = {
  readonly direction: SortDirection;
  readonly on: MediaCharacterSortEnum;
};

/** The connection type for Media. */
export type MediaConnection = {
  readonly __typename?: 'MediaConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Media>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MediaEdge = {
  readonly __typename?: 'MediaEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Media>;
};

/** The role a company played in the creation or localization of a media */
export type MediaProduction = WithTimestamps & {
  readonly __typename?: 'MediaProduction';
  /** The production company */
  readonly company: Producer;
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The media */
  readonly media: Media;
  /** The role this company played */
  readonly role: MediaProductionRoleEnum;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for MediaProduction. */
export type MediaProductionConnection = {
  readonly __typename?: 'MediaProductionConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaProductionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaProduction>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MediaProductionEdge = {
  readonly __typename?: 'MediaProductionEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<MediaProduction>;
};

export enum MediaProductionRoleEnum {
  Licensor = 'LICENSOR',
  Producer = 'PRODUCER',
  Serialization = 'SERIALIZATION',
  Studio = 'STUDIO'
}

/** A simple review that is 140 characters long expressing how you felt about a media */
export type MediaReaction = WithTimestamps & {
  readonly __typename?: 'MediaReaction';
  /** The author who wrote this reaction. */
  readonly author: Profile;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** Whether you have liked this media reaction */
  readonly hasLiked: Scalars['Boolean'];
  readonly id: Scalars['ID'];
  /** The library entry related to this reaction. */
  readonly libraryEntry: LibraryEntry;
  /** Users that have liked this reaction */
  readonly likes: ProfileConnection;
  /** The media related to this reaction. */
  readonly media: Media;
  /** When this media reaction was written based on media progress. */
  readonly progress: Scalars['Int'];
  /** The reaction text related to a media. */
  readonly reaction: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A simple review that is 140 characters long expressing how you felt about a media */
export type MediaReactionLikesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaReactionVoteSortOption>>>;
};

/** The connection type for MediaReaction. */
export type MediaReactionConnection = {
  readonly __typename?: 'MediaReactionConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaReactionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaReaction>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MediaReactionEdge = {
  readonly __typename?: 'MediaReactionEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<MediaReaction>;
};

export enum MediaReactionSortEnum {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT',
  UpVotesCount = 'UP_VOTES_COUNT'
}

export type MediaReactionSortOption = {
  readonly direction: SortDirection;
  readonly on: MediaReactionSortEnum;
};

export enum MediaReactionVoteSortEnum {
  CreatedAt = 'CREATED_AT',
  Following = 'FOLLOWING'
}

export type MediaReactionVoteSortOption = {
  readonly direction: SortDirection;
  readonly on: MediaReactionVoteSortEnum;
};

/** Information about a person working on an anime */
export type MediaStaff = WithTimestamps & {
  readonly __typename?: 'MediaStaff';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The media */
  readonly media: Media;
  /** The person */
  readonly person: Person;
  /** The role this person had in the creation of this media */
  readonly role: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for MediaStaff. */
export type MediaStaffConnection = {
  readonly __typename?: 'MediaStaffConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaStaffEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaStaff>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type MediaStaffEdge = {
  readonly __typename?: 'MediaStaffEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<MediaStaff>;
};

/** これはアニメやマンガです */
export enum MediaTypeEnum {
  Anime = 'ANIME',
  Manga = 'MANGA'
}

export type Mutation = {
  readonly __typename?: 'Mutation';
  readonly account: AccountMutations;
  /** Create a new Kitsu account */
  readonly accountCreate?: Maybe<AccountCreatePayload>;
  readonly anime: AnimeMutations;
  readonly episode: EpisodeMutations;
  readonly libraryEntry: LibraryEntryMutations;
  readonly mapping: MappingMutations;
  readonly post: PostMutations;
  readonly pro: ProMutations;
  readonly wikiSubmission: WikiSubmissionMutations;
};

export type MutationAccountCreateArgs = {
  input: AccountCreateInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  readonly __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars['String']>;
};

/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */
export type Person = WithTimestamps & {
  readonly __typename?: 'Person';
  /** The day when this person was born */
  readonly birthday?: Maybe<Scalars['Date']>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** A brief biography or description of the person. */
  readonly description: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** An image of the person */
  readonly image?: Maybe<Image>;
  /** Information about the person working on specific media */
  readonly mediaStaff?: Maybe<MediaStaffConnection>;
  /** The primary name of this person. */
  readonly name: Scalars['String'];
  /** The name of this person in various languages */
  readonly names: TitlesList;
  /** The URL-friendly identifier of this person. */
  readonly slug: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** The voice-acting roles this person has had. */
  readonly voices?: Maybe<CharacterVoiceConnection>;
};

/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */
export type PersonDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */
export type PersonMediaStaffArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */
export type PersonVoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A post that is visible to your followers and globally in the news-feed. */
export type Post = WithTimestamps & {
  readonly __typename?: 'Post';
  /** The user who created this post. */
  readonly author: Profile;
  /** All comments on this post */
  readonly comments: CommentConnection;
  /** Unmodified content. */
  readonly content?: Maybe<Scalars['String']>;
  /** Html formatted content. */
  readonly contentFormatted?: Maybe<Scalars['String']>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** Users that are watching this post */
  readonly follows: ProfileConnection;
  readonly id: Scalars['ID'];
  /** If a post is Not-Safe-for-Work. */
  readonly isNsfw: Scalars['Boolean'];
  /** If this post spoils the tagged media. */
  readonly isSpoiler: Scalars['Boolean'];
  /** Users that have liked this post */
  readonly likes: ProfileConnection;
  /** When this post was locked. */
  readonly lockedAt?: Maybe<Scalars['ISO8601DateTime']>;
  /** The user who locked this post. */
  readonly lockedBy?: Maybe<Profile>;
  /** The reason why this post was locked. */
  readonly lockedReason?: Maybe<LockedReasonEnum>;
  /** The media tagged in this post. */
  readonly media?: Maybe<Media>;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A post that is visible to your followers and globally in the news-feed. */
export type PostCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<CommentSortOption>>>;
};

/** A post that is visible to your followers and globally in the news-feed. */
export type PostFollowsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A post that is visible to your followers and globally in the news-feed. */
export type PostLikesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<PostLikeSortOption>>>;
};

/** The connection type for Post. */
export type PostConnection = {
  readonly __typename?: 'PostConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<PostEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Post>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PostEdge = {
  readonly __typename?: 'PostEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Post>;
};

export enum PostLikeSortEnum {
  CreatedAt = 'CREATED_AT',
  Following = 'FOLLOWING'
}

export type PostLikeSortOption = {
  readonly direction: SortDirection;
  readonly on: PostLikeSortEnum;
};

export type PostLockInput = {
  readonly id: Scalars['ID'];
  readonly lockedReason: LockedReasonEnum;
};

/** Autogenerated return type of PostLock */
export type PostLockPayload = {
  readonly __typename?: 'PostLockPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly post?: Maybe<Post>;
};

export type PostMutations = {
  readonly __typename?: 'PostMutations';
  /** Lock a Post. */
  readonly lock?: Maybe<PostLockPayload>;
  /** Unlock a Post. */
  readonly unlock?: Maybe<PostUnlockPayload>;
};

export type PostMutationsLockArgs = {
  input: PostLockInput;
};

export type PostMutationsUnlockArgs = {
  input: PostUnlockInput;
};

export enum PostSortEnum {
  CreatedAt = 'CREATED_AT'
}

export type PostSortOption = {
  readonly direction: SortDirection;
  readonly on: PostSortEnum;
};

export type PostUnlockInput = {
  readonly id: Scalars['ID'];
};

/** Autogenerated return type of PostUnlock */
export type PostUnlockPayload = {
  readonly __typename?: 'PostUnlockPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly post?: Maybe<Post>;
};

export type ProMutations = {
  readonly __typename?: 'ProMutations';
  /** Set the user's discord tag */
  readonly setDiscord?: Maybe<ProSetDiscordPayload>;
  /** Set the user's Hall-of-Fame message */
  readonly setMessage?: Maybe<ProSetMessagePayload>;
  /** End the user's pro subscription */
  readonly unsubscribe?: Maybe<ProUnsubscribePayload>;
};

export type ProMutationsSetDiscordArgs = {
  discord: Scalars['String'];
};

export type ProMutationsSetMessageArgs = {
  message: Scalars['String'];
};

/** Autogenerated return type of ProSetDiscord */
export type ProSetDiscordPayload = {
  readonly __typename?: 'ProSetDiscordPayload';
  readonly discord: Scalars['String'];
};

/** Autogenerated return type of ProSetMessage */
export type ProSetMessagePayload = {
  readonly __typename?: 'ProSetMessagePayload';
  readonly message: Scalars['String'];
};

/** A subscription to Kitsu PRO */
export type ProSubscription = WithTimestamps & {
  readonly __typename?: 'ProSubscription';
  /** The account which is subscribed to Pro benefits */
  readonly account: Account;
  /** The billing service used for this subscription */
  readonly billingService: RecurringBillingServiceEnum;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** The tier of Pro the account is subscribed to */
  readonly tier: ProTierEnum;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

export enum ProTierEnum {
  /** Aozora Pro (only hides ads) */
  AoPro = 'AO_PRO',
  /** Aozora Pro+ (only hides ads) */
  AoProPlus = 'AO_PRO_PLUS',
  /** Top tier of Kitsu Pro */
  Patron = 'PATRON',
  /** Basic tier of Kitsu Pro */
  Pro = 'PRO'
}

/** Autogenerated return type of ProUnsubscribe */
export type ProUnsubscribePayload = {
  readonly __typename?: 'ProUnsubscribePayload';
  readonly expiresAt?: Maybe<Scalars['ISO8601DateTime']>;
};

/** A company involved in the creation or localization of media */
export type Producer = WithTimestamps & {
  readonly __typename?: 'Producer';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The name of this production company */
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A user profile on Kitsu */
export type Profile = WithTimestamps & {
  readonly __typename?: 'Profile';
  /** A short biographical blurb about this profile */
  readonly about?: Maybe<Scalars['String']>;
  /** An avatar image to easily identify this profile */
  readonly avatarImage?: Maybe<Image>;
  /** A banner to display at the top of the profile */
  readonly bannerImage?: Maybe<Image>;
  /** When the user was born */
  readonly birthday?: Maybe<Scalars['ISO8601Date']>;
  /** All comments to any post this user has made. */
  readonly comments: CommentConnection;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** Favorite media, characters, and people */
  readonly favorites: FavoriteConnection;
  /** People that follow the user */
  readonly followers: ProfileConnection;
  /** People the user is following */
  readonly following: ProfileConnection;
  /** What the user identifies as */
  readonly gender?: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  /** The user library of their media */
  readonly library: Library;
  /** A list of library events for this user */
  readonly libraryEvents: LibraryEventConnection;
  /** The user's general location */
  readonly location?: Maybe<Scalars['String']>;
  /** Media reactions written by this user. */
  readonly mediaReactions: MediaReactionConnection;
  /** A non-unique publicly visible name for the profile. Minimum of 3 characters and any valid Unicode character */
  readonly name: Scalars['String'];
  /** Post pinned to the user profile */
  readonly pinnedPost?: Maybe<Post>;
  /** All posts this profile has made. */
  readonly posts: PostConnection;
  /** The message this user has submitted to the Hall of Fame */
  readonly proMessage?: Maybe<Scalars['String']>;
  /** The PRO level the user currently has */
  readonly proTier?: Maybe<ProTierEnum>;
  /** Reviews created by this user */
  readonly reviews?: Maybe<ReviewConnection>;
  /** Links to the user on other (social media) sites. */
  readonly siteLinks?: Maybe<SiteLinkConnection>;
  /** The URL-friendly identifier for this profile */
  readonly slug?: Maybe<Scalars['String']>;
  /** The different stats we calculate for this user. */
  readonly stats: ProfileStats;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** A fully qualified URL to the profile */
  readonly url?: Maybe<Scalars['String']>;
  /** The character this profile has declared as their waifu or husbando */
  readonly waifu?: Maybe<Character>;
  /** The properly-gendered term for the user's waifu. This should normally only be 'Waifu' or 'Husbando' but some people are jerks, including the person who wrote this... */
  readonly waifuOrHusbando?: Maybe<Scalars['String']>;
  /** Wiki submissions created by this user */
  readonly wikiSubmissions: WikiSubmissionConnection;
};

/** A user profile on Kitsu */
export type ProfileCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A user profile on Kitsu */
export type ProfileFavoritesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A user profile on Kitsu */
export type ProfileFollowersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<FollowSortOption>>>;
};

/** A user profile on Kitsu */
export type ProfileFollowingArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<FollowSortOption>>>;
};

/** A user profile on Kitsu */
export type ProfileLibraryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  kind?: InputMaybe<ReadonlyArray<LibraryEventKindEnum>>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<LibraryEventSortOption>>>;
};

/** A user profile on Kitsu */
export type ProfileMediaReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<MediaReactionSortOption>>>;
};

/** A user profile on Kitsu */
export type ProfilePostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<PostSortOption>>>;
};

/** A user profile on Kitsu */
export type ProfileReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<WikiSubmissionSortOption>>>;
};

/** A user profile on Kitsu */
export type ProfileSiteLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A user profile on Kitsu */
export type ProfileWikiSubmissionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<WikiSubmissionSortOption>>>;
  statuses?: InputMaybe<ReadonlyArray<WikiSubmissionStatusEnum>>;
};

/** The connection type for Profile. */
export type ProfileConnection = {
  readonly __typename?: 'ProfileConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ProfileEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Profile>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProfileEdge = {
  readonly __typename?: 'ProfileEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Profile>;
};

/** An external site that can be linked to a user. */
export type ProfileLinkSite = WithTimestamps & {
  readonly __typename?: 'ProfileLinkSite';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** Name of the external profile website. */
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** Regex pattern used to validate the profile link. */
  readonly validateFind: Scalars['String'];
  /** Pattern to be replaced after validation. */
  readonly validateReplace: Scalars['String'];
};

/** The different types of user stats that we calculate. */
export type ProfileStats = {
  readonly __typename?: 'ProfileStats';
  /** The total amount of anime you have watched over your whole life. */
  readonly animeAmountConsumed: AnimeAmountConsumed;
  /** The breakdown of the different categories related to the anime you have completed */
  readonly animeCategoryBreakdown: AnimeCategoryBreakdown;
  /** The total amount of manga you ahve read over your whole life. */
  readonly mangaAmountConsumed: MangaAmountConsumed;
  /** The breakdown of the different categories related to the manga you have completed */
  readonly mangaCategoryBreakdown: MangaCategoryBreakdown;
};

export type Query = {
  readonly __typename?: 'Query';
  /** All Anime in the Kitsu database */
  readonly anime: AnimeConnection;
  /** All Anime with specific Status */
  readonly animeByStatus?: Maybe<AnimeConnection>;
  /** All Categories in the Kitsu Database */
  readonly categories?: Maybe<CategoryConnection>;
  /** Kitsu account details. You must supply an Authorization token in header. */
  readonly currentAccount?: Maybe<Account>;
  /** Find a single Anime by ID */
  readonly findAnimeById?: Maybe<Anime>;
  /** Find a single Anime by Slug */
  readonly findAnimeBySlug?: Maybe<Anime>;
  /** Find a single Category by ID */
  readonly findCategoryById?: Maybe<Category>;
  /** Find a single Category by Slug */
  readonly findCategoryBySlug?: Maybe<Category>;
  /** Find a single Character by ID */
  readonly findCharacterById?: Maybe<Character>;
  /** Find a single Character by Slug */
  readonly findCharacterBySlug?: Maybe<Character>;
  /** Find a single Library Entry by ID */
  readonly findLibraryEntryById?: Maybe<LibraryEntry>;
  /** Find a single Library Event by ID */
  readonly findLibraryEventById?: Maybe<LibraryEvent>;
  /** Find a single Manga by ID */
  readonly findMangaById?: Maybe<Manga>;
  /** Find a single Manga by Slug */
  readonly findMangaBySlug?: Maybe<Manga>;
  /** Find a single Person by ID */
  readonly findPersonById?: Maybe<Person>;
  /** Find a single Person by Slug */
  readonly findPersonBySlug?: Maybe<Person>;
  /** Find a single Post by ID */
  readonly findPostById?: Maybe<Post>;
  /** Find a single User by ID */
  readonly findProfileById?: Maybe<Profile>;
  /** Find a single User by Slug */
  readonly findProfileBySlug?: Maybe<Profile>;
  /** Find a single Report by ID */
  readonly findReportById?: Maybe<Report>;
  /** Find a single Wiki Submission by ID */
  readonly findWikiSubmissionById?: Maybe<WikiSubmission>;
  /** All Franchise in the Kitsu database */
  readonly franchises?: Maybe<FranchiseConnection>;
  /** List trending media on Kitsu */
  readonly globalTrending: MediaConnection;
  /** List of Library Entries by MediaType and MediaId */
  readonly libraryEntriesByMedia?: Maybe<LibraryEntryConnection>;
  /** List of Library Entries by MediaType */
  readonly libraryEntriesByMediaType?: Maybe<LibraryEntryConnection>;
  /** List trending media within your network */
  readonly localTrending: MediaConnection;
  /** Find a specific Mapping Item by External ID and External Site. */
  readonly lookupMapping?: Maybe<MappingItemUnion>;
  /** All Manga in the Kitsu database */
  readonly manga: MangaConnection;
  /** All Manga with specific Status */
  readonly mangaByStatus?: Maybe<MangaConnection>;
  /** Patrons sorted by a Proprietary Magic Algorithm */
  readonly patrons: ProfileConnection;
  /** Random anime or manga */
  readonly randomMedia: Media;
  /** All Reports in the Kitsu database */
  readonly reports?: Maybe<ReportConnection>;
  /** Select all Reports that match with a supplied status. */
  readonly reportsByStatus?: Maybe<ReportConnection>;
  /** Search for Anime by title using Algolia. The most relevant results will be at the top. */
  readonly searchAnimeByTitle: AnimeConnection;
  /** Search for Manga by title using Algolia. The most relevant results will be at the top. */
  readonly searchMangaByTitle: MangaConnection;
  /** Search for any media (Anime, Manga) by title using Algolia. If no media_type is supplied, it will search for both. The most relevant results will be at the top. */
  readonly searchMediaByTitle: MediaConnection;
  /** Search for User by username using Algolia. The most relevant results will be at the top. */
  readonly searchProfileByUsername?: Maybe<ProfileConnection>;
  /** Get your current session info */
  readonly session: Session;
  /** Select all Wiki Submissions that match with a supplied status. */
  readonly wikiSubmissionsByStatuses?: Maybe<WikiSubmissionConnection>;
};

export type QueryAnimeArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type QueryAnimeByStatusArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  status: ReleaseStatusEnum;
};

export type QueryCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type QueryFindAnimeByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindAnimeBySlugArgs = {
  slug: Scalars['String'];
};

export type QueryFindCategoryByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindCategoryBySlugArgs = {
  slug: Scalars['String'];
};

export type QueryFindCharacterByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindCharacterBySlugArgs = {
  slug: Scalars['String'];
};

export type QueryFindLibraryEntryByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindLibraryEventByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindMangaByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindMangaBySlugArgs = {
  slug: Scalars['String'];
};

export type QueryFindPersonByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindPersonBySlugArgs = {
  slug: Scalars['String'];
};

export type QueryFindPostByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindProfileByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindProfileBySlugArgs = {
  slug: Scalars['String'];
};

export type QueryFindReportByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFindWikiSubmissionByIdArgs = {
  id: Scalars['ID'];
};

export type QueryFranchisesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type QueryGlobalTrendingArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

export type QueryLibraryEntriesByMediaArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaId: Scalars['ID'];
  mediaType: MediaTypeEnum;
};

export type QueryLibraryEntriesByMediaTypeArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

export type QueryLocalTrendingArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType: MediaTypeEnum;
};

export type QueryLookupMappingArgs = {
  externalId: Scalars['ID'];
  externalSite: MappingExternalSiteEnum;
};

export type QueryMangaArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type QueryMangaByStatusArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  status: ReleaseStatusEnum;
};

export type QueryPatronsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type QueryRandomMediaArgs = {
  ageRatings: ReadonlyArray<AgeRatingEnum>;
  mediaType: MediaTypeEnum;
};

export type QueryReportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type QueryReportsByStatusArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<ReadonlyArray<ReportStatusEnum>>;
};

export type QuerySearchAnimeByTitleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  title: Scalars['String'];
};

export type QuerySearchMangaByTitleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  title: Scalars['String'];
};

export type QuerySearchMediaByTitleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  mediaType?: InputMaybe<MediaTypeEnum>;
  title: Scalars['String'];
};

export type QuerySearchProfileByUsernameArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  username: Scalars['String'];
};

export type QueryWikiSubmissionsByStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReadonlyArray<InputMaybe<WikiSubmissionSortOption>>>;
  statuses?: InputMaybe<ReadonlyArray<WikiSubmissionStatusEnum>>;
};

/** A quote from a media */
export type Quote = WithTimestamps & {
  readonly __typename?: 'Quote';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The lines of the quote */
  readonly lines: QuoteLineConnection;
  /** The media this quote is excerpted from */
  readonly media: Media;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A quote from a media */
export type QuoteLinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Quote. */
export type QuoteConnection = {
  readonly __typename?: 'QuoteConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<QuoteEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Quote>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type QuoteEdge = {
  readonly __typename?: 'QuoteEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Quote>;
};

/** A line in a quote */
export type QuoteLine = WithTimestamps & {
  readonly __typename?: 'QuoteLine';
  /** The character who said this line */
  readonly character: Character;
  /** The line that was spoken */
  readonly content: Scalars['String'];
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The quote this line is in */
  readonly quote: Quote;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for QuoteLine. */
export type QuoteLineConnection = {
  readonly __typename?: 'QuoteLineConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<QuoteLineEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<QuoteLine>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type QuoteLineEdge = {
  readonly __typename?: 'QuoteLineEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<QuoteLine>;
};

export enum RatingSystemEnum {
  /** 1-20 in increments of 1 displayed as 1-10 in 0.5 increments */
  Advanced = 'ADVANCED',
  /** 1-20 in increments of 2 displayed as 5 stars in 0.5 star increments */
  Regular = 'REGULAR',
  /** 1-20 displayed as 4 smileys - Awful (1), Meh (8), Good (14) and Great (20) */
  Simple = 'SIMPLE'
}

export enum RecurringBillingServiceEnum {
  /** Billed through Apple In-App Subscription */
  Apple = 'APPLE',
  /** Billed through Google Play Subscription */
  GooglePlay = 'GOOGLE_PLAY',
  /** Bill a PayPal account */
  Paypal = 'PAYPAL',
  /** Bill a credit card via Stripe */
  Stripe = 'STRIPE'
}

export enum ReleaseSeasonEnum {
  /** Released during the Fall season */
  Fall = 'FALL',
  /** Released during the Spring season */
  Spring = 'SPRING',
  /** Released during the Summer season */
  Summer = 'SUMMER',
  /** Released during the Winter season */
  Winter = 'WINTER'
}

export enum ReleaseStatusEnum {
  /** This media is currently releasing */
  Current = 'CURRENT',
  /** This media is no longer releasing */
  Finished = 'FINISHED',
  /** The release date has not been announced yet */
  Tba = 'TBA',
  /** This media is not released yet */
  Unreleased = 'UNRELEASED',
  /** This media is releasing soon */
  Upcoming = 'UPCOMING'
}

/** A report made by a user */
export type Report = WithTimestamps & {
  readonly __typename?: 'Report';
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** Additional information related to why the report was made */
  readonly explanation?: Maybe<Scalars['String']>;
  readonly id: Scalars['ID'];
  /** The moderator who responded to this report */
  readonly moderator?: Maybe<Profile>;
  /** The entity that the report is related to */
  readonly naughty?: Maybe<ReportItemUnion>;
  /** The reason for why the report was made */
  readonly reason: ReportReasonEnum;
  /** The user who made this report */
  readonly reporter: Profile;
  /** The resolution status for this report */
  readonly status: ReportStatusEnum;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Report. */
export type ReportConnection = {
  readonly __typename?: 'ReportConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReportEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Report>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReportEdge = {
  readonly __typename?: 'ReportEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Report>;
};

/** Objects which are Reportable */
export type ReportItemUnion = Comment | MediaReaction | Post | Review;

export enum ReportReasonEnum {
  /** No bulli! */
  Bullying = 'BULLYING',
  /** Not Safe For Work */
  Nsfw = 'NSFW',
  Offensive = 'OFFENSIVE',
  Other = 'OTHER',
  Spam = 'SPAM',
  Spoiler = 'SPOILER'
}

export enum ReportStatusEnum {
  Declined = 'DECLINED',
  Reported = 'REPORTED',
  Resolved = 'RESOLVED'
}

/** A media review made by a user */
export type Review = WithTimestamps & {
  readonly __typename?: 'Review';
  /** The author who wrote this review. */
  readonly author: Profile;
  /** The review data */
  readonly content: Scalars['String'];
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** The review data formatted */
  readonly formattedContent: Scalars['String'];
  readonly id: Scalars['ID'];
  /** Does this review contain spoilers from the media */
  readonly isSpoiler: Scalars['Boolean'];
  /** The library entry related to this review. */
  readonly libraryEntry: LibraryEntry;
  /** Users who liked this review */
  readonly likes: ProfileConnection;
  /** The media related to this review. */
  readonly media: Media;
  /** When this review was written based on media progress. */
  readonly progress: Scalars['Int'];
  /** The user rating for this media */
  readonly rating: Scalars['Int'];
  /** Potentially migrated over from hummingbird. */
  readonly source: Scalars['String'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A media review made by a user */
export type ReviewLikesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Review. */
export type ReviewConnection = {
  readonly __typename?: 'ReviewConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<ReviewEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Review>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReviewEdge = {
  readonly __typename?: 'ReviewEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Review>;
};

/** Information about a user session */
export type Session = {
  readonly __typename?: 'Session';
  /** The account associated with this session */
  readonly account?: Maybe<Account>;
  /** Single sign-on token for Nolt */
  readonly noltToken: Scalars['String'];
  /** The profile associated with this session */
  readonly profile?: Maybe<Profile>;
};

/** A link to a user's profile on an external site. */
export type SiteLink = WithTimestamps & {
  readonly __typename?: 'SiteLink';
  /** The user profile the site is linked to. */
  readonly author: Profile;
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The actual linked website. */
  readonly site: ProfileLinkSite;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** A fully qualified URL of the user profile on an external site. */
  readonly url: Scalars['String'];
};

/** The connection type for SiteLink. */
export type SiteLinkConnection = {
  readonly __typename?: 'SiteLinkConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<SiteLinkEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<SiteLink>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SiteLinkEdge = {
  readonly __typename?: 'SiteLinkEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<SiteLink>;
};

export enum SitePermissionEnum {
  /** Administrator/staff member of Kitsu */
  Admin = 'ADMIN',
  /** Moderator of community behavior */
  CommunityMod = 'COMMUNITY_MOD',
  /** Maintainer of the Kitsu media database */
  DatabaseMod = 'DATABASE_MOD'
}

export enum SortDirection {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

/** Media that is streamable. */
export type Streamable = {
  /** Spoken language is replaced by language of choice. */
  readonly dubs: ReadonlyArray<Scalars['String']>;
  /** Which regions this video is available in. */
  readonly regions: ReadonlyArray<Scalars['String']>;
  /** The site that is streaming this media. */
  readonly streamer: Streamer;
  /** Languages this is translated to. Usually placed at bottom of media. */
  readonly subs: ReadonlyArray<Scalars['String']>;
};

/** The streaming company. */
export type Streamer = WithTimestamps & {
  readonly __typename?: 'Streamer';
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The name of the site that is streaming this media. */
  readonly siteName: Scalars['String'];
  /** Additional media this site is streaming. */
  readonly streamingLinks: StreamingLinkConnection;
  readonly updatedAt: Scalars['ISO8601DateTime'];
  /** Videos of the media being streamed. */
  readonly videos: VideoConnection;
};

/** The streaming company. */
export type StreamerStreamingLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The streaming company. */
export type StreamerVideosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The stream link. */
export type StreamingLink = Streamable &
  WithTimestamps & {
    readonly __typename?: 'StreamingLink';
    readonly createdAt: Scalars['ISO8601DateTime'];
    /** Spoken language is replaced by language of choice. */
    readonly dubs: ReadonlyArray<Scalars['String']>;
    readonly id: Scalars['ID'];
    /** The media being streamed */
    readonly media: Media;
    /** Which regions this video is available in. */
    readonly regions: ReadonlyArray<Scalars['String']>;
    /** The site that is streaming this media. */
    readonly streamer: Streamer;
    /** Languages this is translated to. Usually placed at bottom of media. */
    readonly subs: ReadonlyArray<Scalars['String']>;
    readonly updatedAt: Scalars['ISO8601DateTime'];
    /** Fully qualified URL for the streaming link. */
    readonly url: Scalars['String'];
  };

/** The connection type for StreamingLink. */
export type StreamingLinkConnection = {
  readonly __typename?: 'StreamingLinkConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<StreamingLinkEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<StreamingLink>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type StreamingLinkEdge = {
  readonly __typename?: 'StreamingLinkEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<StreamingLink>;
};

export enum TitleLanguagePreferenceEnum {
  /** Prefer the most commonly-used title for media */
  Canonical = 'CANONICAL',
  /** Prefer the localized title for media */
  Localized = 'LOCALIZED',
  /** Prefer the romanized title for media */
  Romanized = 'ROMANIZED'
}

export type TitlesList = {
  readonly __typename?: 'TitlesList';
  /** A list of additional, alternative, abbreviated, or unofficial titles */
  readonly alternatives?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** The official or de facto international title */
  readonly canonical: Scalars['String'];
  /** The locale code that identifies which title is used as the canonical title */
  readonly canonicalLocale?: Maybe<Scalars['String']>;
  /** The list of localized titles keyed by locale */
  readonly localized: Scalars['Map'];
  /** The original title of the media in the original language */
  readonly original?: Maybe<Scalars['String']>;
  /** The locale code that identifies which title is used as the original title */
  readonly originalLocale?: Maybe<Scalars['String']>;
  /** The title that best matches the user's preferred settings */
  readonly preferred: Scalars['String'];
  /** The original title, romanized into latin script */
  readonly romanized?: Maybe<Scalars['String']>;
  /** The locale code that identifies which title is used as the romanized title */
  readonly romanizedLocale?: Maybe<Scalars['String']>;
  /** The title translated into the user's locale */
  readonly translated?: Maybe<Scalars['String']>;
  /** The locale code that identifies which title is used as the translated title */
  readonly translatedLocale?: Maybe<Scalars['String']>;
};

export type TitlesListLocalizedArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

export type TitlesListInput = {
  readonly alternatives?: InputMaybe<ReadonlyArray<Scalars['String']>>;
  readonly canonical?: InputMaybe<Scalars['String']>;
  readonly canonicalLocale?: InputMaybe<Scalars['String']>;
  readonly localized?: InputMaybe<Scalars['Map']>;
};

/** Media units such as episodes or chapters */
export type Unit = {
  /** A brief summary or description of the unit */
  readonly description: Scalars['Map'];
  readonly id: Scalars['ID'];
  /** The sequence number of this unit */
  readonly number: Scalars['Int'];
  /** A thumbnail image for the unit */
  readonly thumbnail?: Maybe<Image>;
  /** The titles for this unit in various locales */
  readonly titles: TitlesList;
};

/** Media units such as episodes or chapters */
export type UnitDescriptionArgs = {
  locales?: InputMaybe<ReadonlyArray<Scalars['String']>>;
};

export type ValidationError = Error & {
  readonly __typename?: 'ValidationError';
  /** The error code. */
  readonly code?: Maybe<Scalars['String']>;
  /** A description of the error */
  readonly message: Scalars['String'];
  /** Which input value this error came from */
  readonly path?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** The media video. */
export type Video = Streamable &
  WithTimestamps & {
    readonly __typename?: 'Video';
    readonly createdAt: Scalars['ISO8601DateTime'];
    /** Spoken language is replaced by language of choice. */
    readonly dubs: ReadonlyArray<Scalars['String']>;
    /** The episode of this video */
    readonly episode: Episode;
    readonly id: Scalars['ID'];
    /** Which regions this video is available in. */
    readonly regions: ReadonlyArray<Scalars['String']>;
    /** The site that is streaming this media. */
    readonly streamer: Streamer;
    /** Languages this is translated to. Usually placed at bottom of media. */
    readonly subs: ReadonlyArray<Scalars['String']>;
    readonly updatedAt: Scalars['ISO8601DateTime'];
    /** The url of the video. */
    readonly url: Scalars['String'];
  };

/** The connection type for Video. */
export type VideoConnection = {
  readonly __typename?: 'VideoConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<VideoEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<Video>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type VideoEdge = {
  readonly __typename?: 'VideoEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<Video>;
};

/** A manga volume which can contain multiple chapters. */
export type Volume = WithTimestamps & {
  readonly __typename?: 'Volume';
  /** The chapters in this volume. */
  readonly chapters?: Maybe<ChapterConnection>;
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly id: Scalars['ID'];
  /** The isbn number of this volume. */
  readonly isbn: ReadonlyArray<Scalars['String']>;
  /** The manga this volume is in. */
  readonly manga: Manga;
  /** The volume number. */
  readonly number: Scalars['Int'];
  /** The date when this chapter was released. */
  readonly published?: Maybe<Scalars['ISO8601Date']>;
  /** The titles for this chapter in various locales */
  readonly titles: TitlesList;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** A manga volume which can contain multiple chapters. */
export type VolumeChaptersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A Wiki Submission is used to either create or edit existing data in our database. This will allow a simple and convient way for users to submit issues/corrections without all the work being left to the mods. */
export type WikiSubmission = WithTimestamps & {
  readonly __typename?: 'WikiSubmission';
  /** The user who created this draft */
  readonly author: Profile;
  readonly createdAt: Scalars['ISO8601DateTime'];
  /** The full object that holds all the details for any modifications/additions/deletions made to the entity you are editing. This will be validated using JSON Schema. */
  readonly data?: Maybe<Scalars['JSON']>;
  readonly id: Scalars['ID'];
  /** Any additional information that may need to be provided related to the Wiki Submission */
  readonly notes?: Maybe<Scalars['String']>;
  /** The status of the Wiki Submission */
  readonly status: WikiSubmissionStatusEnum;
  /** The title given to the Wiki Submission. This will default to the title of what is being edited. */
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for WikiSubmission. */
export type WikiSubmissionConnection = {
  readonly __typename?: 'WikiSubmissionConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<Maybe<WikiSubmissionEdge>>>;
  /** A list of nodes. */
  readonly nodes?: Maybe<ReadonlyArray<Maybe<WikiSubmission>>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
  /** The total amount of nodes. */
  readonly totalCount: Scalars['Int'];
};

export type WikiSubmissionCreateDraftInput = {
  readonly data: Scalars['JSON'];
  readonly notes?: InputMaybe<Scalars['String']>;
  readonly title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of WikiSubmissionCreateDraft */
export type WikiSubmissionCreateDraftPayload = {
  readonly __typename?: 'WikiSubmissionCreateDraftPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly wikiSubmission?: Maybe<WikiSubmission>;
};

/** An edge in a connection. */
export type WikiSubmissionEdge = {
  readonly __typename?: 'WikiSubmissionEdge';
  /** A cursor for use in pagination. */
  readonly cursor: Scalars['String'];
  /** The item at the end of the edge. */
  readonly node?: Maybe<WikiSubmission>;
};

export type WikiSubmissionMutations = {
  readonly __typename?: 'WikiSubmissionMutations';
  /** Create a wiki submission draft */
  readonly createDraft?: Maybe<WikiSubmissionCreateDraftPayload>;
  /** Submit a wiki submission draft */
  readonly submitDraft?: Maybe<WikiSubmissionSubmitDraftPayload>;
  /** Update a wiki submission draft */
  readonly updateDraft?: Maybe<WikiSubmissionUpdateDraftPayload>;
};

export type WikiSubmissionMutationsCreateDraftArgs = {
  input: WikiSubmissionCreateDraftInput;
};

export type WikiSubmissionMutationsSubmitDraftArgs = {
  input: WikiSubmissionSubmitDraftInput;
};

export type WikiSubmissionMutationsUpdateDraftArgs = {
  input: WikiSubmissionUpdateDraftInput;
};

export enum WikiSubmissionSortEnum {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type WikiSubmissionSortOption = {
  readonly direction: SortDirection;
  readonly on: WikiSubmissionSortEnum;
};

export enum WikiSubmissionStatusEnum {
  Approved = 'APPROVED',
  Draft = 'DRAFT',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export type WikiSubmissionSubmitDraftInput = {
  readonly data: Scalars['JSON'];
  readonly id: Scalars['ID'];
  readonly notes?: InputMaybe<Scalars['String']>;
  readonly title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of WikiSubmissionSubmitDraft */
export type WikiSubmissionSubmitDraftPayload = {
  readonly __typename?: 'WikiSubmissionSubmitDraftPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly wikiSubmission?: Maybe<WikiSubmission>;
};

export type WikiSubmissionUpdateDraftInput = {
  readonly data: Scalars['JSON'];
  readonly id: Scalars['ID'];
  readonly notes?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of WikiSubmissionUpdateDraft */
export type WikiSubmissionUpdateDraftPayload = {
  readonly __typename?: 'WikiSubmissionUpdateDraftPayload';
  readonly errors?: Maybe<ReadonlyArray<Error>>;
  readonly wikiSubmission?: Maybe<WikiSubmission>;
};

export type WithTimestamps = {
  readonly createdAt: Scalars['ISO8601DateTime'];
  readonly updatedAt: Scalars['ISO8601DateTime'];
};
